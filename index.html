<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Indexes Viewer</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <script src="https://unpkg.com/navigo@8.11.1/lib/navigo.min.js"></script>
  <style id="dynamic-styles"></style>
  <style>
    .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px; /* Space between items */
        max-width: 100%; /* Ensure it fits the container */
        box-sizing: border-box;
    }

    .stats > div {
        white-space: nowrap; /* Prevent text wrapping */
    }

    .correlation-table {
      width: 10%;
      overflow-x: auto;
      margin: auto;
    }
    .correlation-table th {
      text-align: right;
      white-space: nowrap;
      left: 0px;
      position: sticky;
      font-weight: normal;
    }
    .correlation-table th:not(:first-child) {
      writing-mode: vertical-lr;
    }
    .correlation-table td {
      text-align: right;
    }
    .correlation-table-container {
      max-width: 100%;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark mb-4">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Indexes Viewer</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <span class="ms-auto">
          <input class="form-check-input" type="checkbox" value="" id="adjust-currency" checked>
          <label class="form-check-label" for="adjust-currency">
            Adjust currency
          </label>
        </span>
        <span style="margin-left: 1em">
          <input class="form-check-input" type="checkbox" value="" id="adjust-inflation" checked>
          <label class="form-check-label" for="adjust-inflation">
            Adjust inflation
          </label>
        </span>
        <span class="kde-controls" style="margin-left: 1em">
          <label for="xMinSelect" style="margin-right: 0.5em">Min:</label>
          <select id="xMinSelect" class="form-select d-inline-block" style="width: auto; margin-right: 1em">
          </select>
          <label for="xMaxSelect" style="margin-right: 0.5em">Max:</label>
          <select id="xMaxSelect" class="form-select d-inline-block" style="width: auto">
          </select>
        </span>
        <select style="margin-left: 1em" id="horizonSelect" class="form-select horizon-select"></select>
      </div>
    </div>
  </nav>
  <div id="app" class="container"></div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Determine the base path dynamically
    const baseUrl = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) + '/';

    const COLORS = {
      background: '#212529',
      navbar: '#343a40',
      text: '#f8f9fa',
      link: '#a3e1d4',
      linkHover: '#f5b7b1',
      chartLine: '#a3e1d4',
      chartFill: 'rgba(163, 225, 212, 0.7)',
      kdeLine: '#f5b7b1',
      kdeFills: [
        'rgba(245, 183, 177, 0.7)', 'rgba(250, 215, 160, 0.7)', 'rgba(163, 225, 212, 0.7)',
        'rgba(164, 202, 240, 0.7)', 'rgba(204, 182, 255, 0.7)', 'rgba(221, 221, 221, 0.7)'
      ],
      meanLine: 'rgb(0, 255, 0)',
      medianLine: 'rgb(0, 0, 255)',
      zeroLine: 'rgb(255, 255, 255)',
      grid: '#495057',
      greenLight: 'hsl(120, 40%, 70%)',
      greenDark: 'hsl(120, 20%, 50%)'
    };

    document.getElementById('dynamic-styles').textContent = `
      body { font-family: Arial, sans-serif; padding: 20px; background-color: ${COLORS.background}; color: ${COLORS.text}; }
      .plot-div { width: 100%; height: 400px; }
      .navbar { background-color: ${COLORS.navbar} !important; border-radius: 10px; padding: 5px 10px; }
      a { color: ${COLORS.link}; }
      a:hover { color: ${COLORS.linkHover}; }
      .horizon-select { min-width: 120px; max-width: 30%; }
      .table { margin-bottom: 20px; }
      .table td.number, .table th.number { text-align: right; }
      .sort-link { text-decoration: none; margin-left: 5px; }
      .sort-link:hover { color: ${COLORS.linkHover}; }
    `;

    const COMBINATIONS = (() => {
      const yearsOptions = [10, 15, 20, 25, 'max'];
      const holdOptions = [1.0, 3.0, 5.0, 10.0];
      return holdOptions.flatMap(hold =>
        yearsOptions.map(years => ({
          hold: hold.toFixed(1),
          years,
          value: `hold-${hold.toFixed(1)}/years-${years}`,
          label: `Hold for ${hold} years / Data for ${years === 'max' ? 'all' : years} years`
        }))
      ).filter(value => value.years == "max" || (value.years > new Number(value.hold)));
    })();

    const app = document.getElementById('app');
    const router = new Navigo(baseUrl, { hash: true });
    let selectedCombo = "hold-10.0/years-20";
    let adjustCurrency = "adjust-currency";
    let adjustInflation = "adjust-inflation";
    let xAxisMin = 'Auto';
    let xAxisMax = 'Auto';
    let indexesMeta = {}, simulationsData = {}, etfsData = [], currentIndexName = null;
    let sortState = { column: 0, ascending: true };
    let currentRoute = 'home';
    let correlationsData = {};
    let minCorrelation = 1;

    const baseLayout = {
      plot_bgcolor: COLORS.navbar,
      paper_bgcolor: COLORS.background,
      font: { color: COLORS.text },
      xaxis: { gridcolor: COLORS.grid },
      yaxis: { gridcolor: COLORS.grid },
      margin: { t: 20, b: 50, l: 50, r: 20 },
      showlegend: false
    };

    const columns = [
      { name: 'Index', sort: (a, b) => a.meta.full_name.localeCompare(b.meta.full_name) },
      { name: 'Curr.', sort: (a, b) => a.meta.currency.localeCompare(b.meta.currency) },
      { name: 'Years', numeric: true, sort: (a, b) => (a.meta.years || 0) - (b.meta.years || 0), isHigherBetter: true },
      { name: 'Mean', numeric: true, sort: (a, b) => (a.simData.mean || 0) - (b.simData.mean || 0), isPercent: true, isHigherBetter: true },
      { name: 'Median', numeric: true, sort: (a, b) => (a.simData.median || 0) - (b.simData.median || 0), isPercent: true, isHigherBetter: true },
      { name: 'σ', numeric: true, sort: (a, b) => (a.simData.std_dev || 0) - (b.simData.std_dev || 0), isLowerBetter: true },
      { name: 'SE', numeric: true, sort: (a, b) => (a.simData.std_err || 0) - (b.simData.std_err || 0), isLowerBetter: true },
      { name: 'Min', numeric: true, sort: (a, b) => (a.simData.min || 0) - (b.simData.min || 0), isPercent: true, isHigherBetter: true },
      { name: 'Max', numeric: true, sort: (a, b) => (a.simData.max || 0) - (b.simData.max || 0), isPercent: true, isHigherBetter: true },
      { name: 'ETF #', numeric: true, sort: (a, b) => (a.etfCount || 0) - (b.etfCount || 0), isHigherBetter: true }
    ];

    // Generate options for x-axis range dropdowns (-20 to +20)
    const rangeMin = -20;
    const rangeMax = 20;
    const rangeOptions = ['Auto', ...Array.from({length: rangeMax - rangeMin + 1}, (_, i) => i + rangeMin)];

    const horizonSelect = document.getElementById('horizonSelect');
    horizonSelect.innerHTML = COMBINATIONS.map(c => `<option value="${c.value}">${c.label}</option>`).join('');
    horizonSelect.value = selectedCombo;

    const adjustCurrencyCheckbox = document.getElementById('adjust-currency');
    adjustCurrencyCheckbox.checked = adjustCurrency === "adjust-currency";
    const adjustInflationCheckbox = document.getElementById('adjust-inflation');
    adjustInflationCheckbox.checked = adjustInflation === "adjust-inflation";

    const homeLink = document.querySelector('.navbar-brand');

    // Centralized CSV Parsing
    function parseCSV(csvData) {
      const lines = csvData.trim().split('\n').slice(1); // Skip header
      return lines.map(line => {
        const result = [];
        let current = '', inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"' && !inQuotes) {
            inQuotes = true;
          } else if (char === '"' && inQuotes) {
            inQuotes = false;
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current.trim()); // Push last field
        return result.map(field => field.replace(/^"|"$/g, '')); // Strip quotes
      });
    }

    function fetchCSV(url) {
      return fetch(`${baseUrl}${url}`).then(res => res.text()).then(parseCSV);
    }

    function loadCorrelationsData() {
      return fetchCSV('facts/indexes-correlation.csv').then(rows => {
        correlationsData = {};
        rows.forEach(([a, b, , correlation]) => {
          if (!correlationsData[a]) correlationsData[a] = {};
          if (!correlationsData[b]) correlationsData[b] = {};
          value = parseFloat(correlation)
          if (minCorrelation > value)
            minCorrelation = value;
          value = parseFloat(correlation);
          correlationsData[a][b] = value;
          correlationsData[b][a] = value;
        });
      });
    }

    // Data Loading
    function loadIndexesMeta() {
      // Wait for ETFs to be loaded first
      return loadEtfsData().then(() => {
        return fetchCSV('facts/indexes.csv').then(rows => {
          const currentDate = new Date('2025-04-06');
          indexesMeta = {};
          rows.forEach(([name, full_name, code, currency, earliest_date]) => {
            // Only include indices that have at least one ETF
            if (name === "null" || etfsData.some(etf => etf.indexName === name)) {
              const years = ((currentDate - new Date(earliest_date)) / (1000 * 60 * 60 * 24 * 365.25)).toFixed(1);
              indexesMeta[name] = { full_name, code, currency, earliest_date, years: parseFloat(years) };
            }
          });
        });
      });
    }

    function loadSimulationsData() {
      return fetchCSV('simulations/indexes.csv').then(rows => {
        rows.forEach(([index, hold_years, total_years, adjustCurrency, adjustInflation, simulations, mean, median, std_dev, std_err, min, max]) => {
          // Only process simulations for indices in indexesMeta
          if (indexesMeta[index]) {
            if (!simulationsData[index]) simulationsData[index] = {};
            const key = `hold-${hold_years}/years-${total_years}/${adjustCurrency}/${adjustInflation}`;
            simulationsData[index][key] = {
              simulations: Math.round(Number(simulations)),
              mean: Number(mean).toFixed(2),
              median: Number(median).toFixed(2),
              std_dev: Number(std_dev).toFixed(2),
              std_err: Number(std_err).toFixed(4),
              min: Number(min).toFixed(2),
              max: Number(max).toFixed(2)
            };
          }
        });
      });
    }

    function replaceShareName(name) {
      return name.replace("by DWS", "");
    }

    function loadEtfsData() {
      return fetchCSV('facts/etfs.csv').then(rows => {
        const currentDate = new Date('2025-04-06');
        etfsData = rows.map(([indexName, isin, shareName, currencyHedged, expenseRatio, provider, replicationMethod, replicationModel, dividendPolicyId, creationDate, currency, size, trackingError, trackingDifference, description, trackinsightTicker]) => {
          const years = ((currentDate - new Date(creationDate)) / (1000 * 60 * 60 * 24 * 365.25)).toFixed(1);
          shareName = replaceShareName(shareName);
          return {
            indexName, isin, shareName, currencyHedged: currencyHedged === 'True', expenseRatio: Number(expenseRatio),
            provider, replicationMethod, replicationModel, dividendPolicyId, creationDate, years: parseFloat(years),
            currency, size: Number(size) / 1e9, trackingError: Number(trackingError), trackingDifference: Number(trackingDifference),
            description, trackinsightTicker
          };
        }).filter(entry => (entry.currencyHedged && entry.currency == "EUR") || entry.currency == "USD");
      });
    }

    const dataLoaded = Promise.all([loadIndexesMeta(), loadSimulationsData(), loadCorrelationsData()]);

    // Utility Functions
    function buildQuery() {
      const params = {
        combo: selectedCombo,
        ac: adjustCurrency === "adjust-currency" ? '1' : '0',
        ai: adjustInflation === "adjust-inflation" ? '1' : '0',
        s: `${sortState.column},${sortState.ascending ? 'true' : 'false'}`,
        xmin: xAxisMin !== 'Auto' ? xAxisMin : '',
        xmax: xAxisMax !== 'Auto' ? xAxisMax : ''
      };
      return new URLSearchParams(params).toString();
    }

    function updateUrl() {
      const lastRoute = router.lastResolved();
      const path = lastRoute && lastRoute.length > 0 ? lastRoute[0].url : (currentRoute === 'view' && currentIndexName ? `${baseUrl}view/${currentIndexName}` : '/');
      const query = buildQuery();
      router.navigate(path + (query ? '?' + query : ''));
    }

    function updateHomeLink() {
      homeLink.href = `#${baseUrl}?${buildQuery()}`;
    }

    function applyParams(params) {
      const p = params || {};
      const ac = p.ac ?? '1';
      adjustCurrency = ac === '1' ? "adjust-currency" : "ignore-currency";
      const ai = p.ai ?? '1';
      adjustInflation = ai === '1' ? "adjust-inflation" : "ignore-inflation";
      selectedCombo = p.combo ?? "hold-10.0/years-20";
      const s = p.s ?? '0,true';
      const [col, ascStr] = s.split(',');
      sortState.column = parseInt(col ?? 0);
      sortState.ascending = ascStr === 'true';
      xAxisMin = p.xmin && rangeOptions.includes(Number(p.xmin)) ? Number(p.xmin) : 'Auto';
      xAxisMax = p.xmax && rangeOptions.includes(Number(p.xmax)) ? Number(p.xmax) : 'Auto';

      horizonSelect.value = selectedCombo;
      adjustCurrencyCheckbox.checked = ac === '1';
      adjustInflationCheckbox.checked = ai === '1';
      const xMinSelect = document.getElementById('xMinSelect');
      const xMaxSelect = document.getElementById('xMaxSelect');
      if (xMinSelect) xMinSelect.value = xAxisMin;
      if (xMaxSelect) xMaxSelect.value = xAxisMax;

      xMinSelect.innerHTML = `
        ${rangeOptions.map(val => `<option value="${val}">${val >= 0 ? '+' : ''}${val}%</option>`).join('')}
      `;
      xMaxSelect.innerHTML = `
        ${rangeOptions.map(val => `<option value="${val}">${val >= 0 ? '+' : ''}${val}%</option>`).join('')}
      `;

      xMinSelect.value = xAxisMin;
      xMaxSelect.value = xAxisMax;

      updateHomeLink();
    }

    function getColorScale(value, min, max, isLowerBetter = false) {
      if (value === undefined) return COLORS.text;
      const ratio = (value - min) / (max - min) || 0;
      return `hsl(${isLowerBetter ? 120 * (1 - ratio) : 120 * ratio}, 40%, 70%)`;
    }

    function sortTable(columnIndex) {
      sortState = { column: columnIndex, ascending: sortState.column === columnIndex ? !sortState.ascending : true };
      updateUrl();
      updateHomeLink();
      renderTable();
    }

    function updateSortIndicators() {
      document.querySelectorAll('#indexesTable .sort-link').forEach(link => {
        link.textContent = sortState.column === parseInt(link.dataset.col) ? (sortState.ascending ? '▼' : '▲') : '▼';
      });
    }

    function renderCorrelationTable(digits, selectedIndex = null) {
      const queryStr = buildQuery();

      let indexes = Object.keys(indexesMeta).sort((a, b) =>
        indexesMeta[a].full_name.localeCompare(indexesMeta[b].full_name)
      );

      // Sort indexes by correlation in ascending order if selectedIndex is provided
      if (selectedIndex) {
        indexes = indexes.sort((a, b) => {
          const corrA = correlationsData[a]?.[selectedIndex] || 0;
          const corrB = correlationsData[b]?.[selectedIndex] || 0;
          return corrA - corrB; // Ascending order
        });
      }

      // Determine headers based on whether a specific index is selected
      const headerRow = selectedIndex
        ? ""
        : `<tr><th></th>${indexes.map(index => `<th><a href="#${baseUrl}view/${index}?${queryStr}">${indexesMeta[index].full_name || index}</a></th>`).join('')}</tr>`;

      // Determine which indexes to include in columns
      const columns = selectedIndex ? [selectedIndex] : indexes;

      // Generate table body
      const bodyRows = indexes.map(indexA => {
        if (selectedIndex && indexA === selectedIndex)
          return "";
        const cells = columns.map(indexB => {
          const value = correlationsData[indexA]?.[indexB];
          if (value === undefined)
            return `<td></td>`;
          const correlation = value.toFixed(digits).replace("1.00", "1").replace("0.", ".") || '';
          return `<td style="color: ${getColorScale(Math.max(0.9, value), 0.9, 1, true)}">${correlation}</td>`;
        });
        return `
          <tr>
            <th><a href="#${baseUrl}view/${indexA}?${queryStr}">${indexesMeta[indexA].full_name || indexA}</a></th>
            ${cells.join('')}
          </tr>
        `;
      }).join('');

      return `
        <h3>Index Correlations</h3>
        <div class="correlation-table-container">
          <table class="table table-dark table-striped table-hover correlation-table">
            <thead>${headerRow}</thead>
            <tbody>${bodyRows}</tbody>
          </table>
        </div>
      `;
    }

    // Rendering Functions
    function renderTable() {
      const indexesData = Object.keys(indexesMeta).map(name => ({
        name, meta: indexesMeta[name], simData: simulationsData[name]?.[`${selectedCombo}/${adjustCurrency}/${adjustInflation}`] || {},
        etfCount: etfsData.filter(etf => etf.indexName === name).length
      }));

      // a - b
      function sortColumn(a, b) {
        if (a.simData.mean === undefined) return Infinity;
        if (b.simData.mean === undefined) return -Infinity;
        return sortState.ascending ? columns[sortState.column].sort(b, a) : columns[sortState.column].sort(a, b);
      }

      indexesData.sort(sortColumn);
      const ranges = columns.reduce((acc, col) => {
        if (col.numeric) {
          const key = col.name;
          const values = indexesData.map(d => (key === 'Years' ? d.meta.years : key === 'ETFs' ? d.etfCount : d.simData[key.toLowerCase().replace(' ', '_')])).filter(v => v !== undefined);
          acc[key] = { min: Math.min(...values), max: Math.max(...values) };
        }
        return acc;
      }, {});
      const formatPercent = val => val !== undefined ? (val > 0 ? `+${val}%` : `${val}%`) : 'N/A';
      const formatNumber = val => val !== undefined ? val : 'N/A';
      const queryStr = buildQuery();
      document.querySelector('#indexesTable tbody').innerHTML = indexesData.map(data => {
        const { simData, meta, etfCount } = data;
        return `<tr>
          <td class="number"><a href="#${baseUrl}view/${data.name}?${queryStr}">${meta.full_name || 'N/A'}</a></td>
          <td>${meta.currency || 'N/A'}</td>
          <td class="number" style="color: ${getColorScale(meta.years, ranges.Years.min, ranges.Years.max)}">${formatNumber(meta.years)}</td>
          <td class="number" style="color: ${getColorScale(simData.mean, ranges.Mean.min, ranges.Mean.max)}">${formatPercent(simData.mean)}</td>
          <td class="number" style="color: ${getColorScale(simData.median, ranges.Median.min, ranges.Median.max)}">${formatPercent(simData.median)}</td>
          <td class="number" style="color: ${getColorScale(simData.std_dev, ranges['σ'].min, ranges['σ'].max, true)}">${formatNumber(simData.std_dev)}</td>
          <td class="number" style="color: ${getColorScale(simData.std_err, ranges['SE'].min, ranges['SE'].max, true)}">${formatNumber(simData.std_err)}</td>
          <td class="number" style="color: ${getColorScale(simData.min, ranges.Min.min, ranges.Min.max)}">${formatPercent(simData.min)}</td>
          <td class="number" style="color: ${getColorScale(simData.max, ranges.Max.min, ranges.Max.max)}">${formatPercent(simData.max)}</td>
          <td class="number" style="color: ${getColorScale(etfCount, ranges["ETF #"].min, ranges["ETF #"].max)}">${formatNumber(etfCount)}</td>
        </tr>`;
      }).join('');
      updateSortIndicators();
    }

    function showTable() {
      app.innerHTML = `
        <table id="indexesTable" class="table table-dark table-striped table-hover">
          <thead><tr>${columns.map((col, i) => `<th${col.numeric ? ' class="number"' : ''}>${col.name} <a href="#" class="sort-link" data-col="${i}">▼</a></th>`).join('')}</tr></thead>
          <tbody></tbody>
        </table>
        ${renderCorrelationTable(2)}
      `;
      renderTable();
      document.querySelectorAll('#indexesTable .sort-link').forEach(link => link.addEventListener('click', e => { e.preventDefault(); sortTable(parseInt(link.dataset.col)); }));
    }

    function renderChart(name, x, y) {
      const fullName = indexesMeta[name]?.full_name || 'N/A';
      Plotly.newPlot('chartDiv', [{
        x, y, type: 'scatter', mode: 'lines', fill: 'tozeroy', line: { color: COLORS.chartLine }, fillcolor: COLORS.chartFill, name: fullName
      }], { ...baseLayout, xaxis: { ...baseLayout.xaxis, title: 'Date' }, yaxis: { ...baseLayout.yaxis, title: 'Value' } });
    }

    function renderKDE(divId, data) {
      const x = data.kde_points.map(point => point.x);
      const y = data.kde_points.map(point => point.density);
      const percentiles = data.percentiles;
      const traces = COLORS.kdeFills.map((color, i) => {
        const ranges = [null, '5th', '25th', '50th', '75th', '95th', null];
        const [min, max] = [ranges[i], ranges[i + 1]].map(r => r ? percentiles[r] : null);
        const startIdx = min === null ? 0 : x.findIndex(val => val > min);
        const endIdx = max === null ? x.length : x.findIndex(val => val >= max) + 1;
        return { x: x.slice(startIdx, endIdx), y: y.slice(startIdx, endIdx), type: 'scatter', mode: 'lines', fill: 'tozeroy', fillcolor: color, line: { width: 0 } };
      });
      traces.push({ x, y, type: 'scatter', mode: 'lines', line: { shape: 'spline', color: COLORS.kdeLine } });
      const verticalLinesData = [
        { value: data.mean, color: COLORS.meanLine, dash: 'dash' },
        { value: data.median, color: COLORS.medianLine, dash: 'dash' },
        { value: 0, color: COLORS.zeroLine, dash: 'solid' }
      ];
      traces.push(...verticalLinesData.map(line => ({
        x: [line.value, line.value], y: [0, Math.max(...y)], type: 'scatter', mode: 'lines', line: { color: line.color, dash: line.dash }
      })));
      const tickVals = x.filter((_, i) => i % Math.floor(x.length / 5) === 0);
      const tickText = tickVals.map(val => val.toFixed(2) > 0 ? `+${val.toFixed(2)}%` : `${val.toFixed(2)}%`);

      // Apply x-axis range if specified
      const xaxis = {
        ...baseLayout.xaxis,
        title: 'Return',
        tickvals: tickVals,
        ticktext: tickText,
        tickformat: '.2f'
      };

      if (xAxisMin !== 'Auto') xaxis.range = [xAxisMin, xaxis.range ? xaxis.range[1] : Math.max(...x)];
      if (xAxisMax !== 'Auto') xaxis.range = [xaxis.range ? xaxis.range[0] : Math.min(...x), xAxisMax];

      Plotly.newPlot(divId, traces, {
        ...baseLayout,
        xaxis,
        yaxis: { ...baseLayout.yaxis, title: 'Density' },
        shapes: verticalLinesData.map(line => ({
          type: 'line',
          x0: line.value,
          x1: line.value,
          y0: 0,
          y1: Math.max(...y),
          line: { color: line.color, dash: line.dash }
        }))
      });
    }

    function updateKDE(name) {
      if (!indexesMeta[name]) return;
      const [hold, years] = selectedCombo.split('/').map(part => part.split('-')[1]);
      document.getElementById('kdePlot').innerHTML = "";
      fetch(`${baseUrl}simulations/${name}/hold-${hold}/years-${years}/${adjustCurrency}/${adjustInflation}/kde.json`)
        .then(res => res.json())
        .then(data => renderKDE('kdePlot', data))
        .catch(() => document.getElementById('kdePlot').innerHTML = `<p class="text-danger">No data for ${hold}-year hold / ${years}-year simulation.</p>`);
    }

    function renderEtfsTable(name) {
      if (!indexesMeta[name]) return '<p>Index not found.</p>';
      const relatedEtfs = etfsData.filter(etf => etf.indexName === name);
      if (!relatedEtfs.length) return '<p>No ETFs available for this index.</p>';

      const headers = ['ISIN', 'Provider', 'Cost', 'Currency', 'Size', 'Years', 'Dividend', 'R. Method', 'R. Model', 'Trk. Error', 'Trk. Difference', 'BI', 'TI', 'JE'];
      const tableHeader = `<thead><tr>${headers.map(header => `<th${['Size', 'Cost', 'Years', 'Trk. Error', 'Trk. Difference'].includes(header) ? ' class="number"' : ''}>${header}</th>`).join('')}</tr></thead>`;

      const ranges = {
        years: { min: Math.min(...relatedEtfs.map(e => e.years)), max: Math.max(...relatedEtfs.map(e => e.years)) },
        expenseRatio: { min: Math.min(...relatedEtfs.map(e => e.expenseRatio)), max: Math.max(...relatedEtfs.map(e => e.expenseRatio)) },
        trackingError: { min: Math.min(...relatedEtfs.map(e => e.trackingError)), max: Math.max(...relatedEtfs.map(e => e.trackingError)) },
        trackingDifference: { min: Math.min(...relatedEtfs.map(e => e.trackingDifference)), max: Math.max(...relatedEtfs.map(e => e.trackingDifference)) }
      };

      const tableBody = relatedEtfs.map(etf => `
        <tr>
          <td title="${etf.shareName}" style="font-family: monospace">${etf.isin}</td>
          <td>${etf.provider}</td>
          <td class="number" style="color: ${getColorScale(etf.expenseRatio, ranges.expenseRatio.min, ranges.expenseRatio.max, true)}">${(etf.expenseRatio * 100).toFixed(2)}%</td>
          <td>${etf.currency}${etf.currencyHedged ? " (Hed)" : ""}</td>
          <td class="number">${etf.size.toFixed(2)}</td>
          <td class="number" style="color: ${getColorScale(etf.years, ranges.years.min, ranges.years.max)}">${etf.years}</td>
          <td>${etf.dividendPolicyId}</td>
          <td>${etf.replicationMethod}</td>
          <td>${etf.replicationModel}</td>
          <td class="number" style="color: ${getColorScale(etf.trackingError, ranges.trackingError.min, ranges.trackingError.max, true)}">${(etf.trackingError * 100).toFixed(2)}%</td>
          <td class="number" style="color: ${getColorScale(etf.trackingDifference, ranges.trackingDifference.min, ranges.trackingDifference.max, false)}">${(etf.trackingDifference * 100).toFixed(2)}%</td>
          <td><a href="https://www.borsaitaliana.it/borsa/etf/scheda/${etf.isin}.html" target="_blank">BI</a></td>
          <td><a href="https://www.trackinsight.com/en/fund/${etf.trackinsightTicker}" target="_blank">TI</a></td>
          <td><a href="https://www.justetf.com/en/etf-profile.html?isin=${etf.isin}" target="_blank">JE</a></td>
        </tr>
      `).join('');

      return `
        <h3>Related ETFs</h3>
        <table class="table table-dark table-striped table-hover" id="etfsTable">
          ${tableHeader}
          <tbody>${tableBody}</tbody>
        </table>
      `;
    }

    function showChart(name) {
      currentIndexName = name;
      let { full_name = 'N/A', years = "N/A" } = indexesMeta[name] || {};
      const age = years;
      const [hold, yearsData] = selectedCombo.split('/').map(part => part.split('-')[1]);
      const key = `hold-${hold}/years-${yearsData}/${adjustCurrency}/${adjustInflation}`;
      const simulation = simulationsData[name]?.[key] || {};
      app.innerHTML = `
        <h2>${full_name}</h2>
        <div class="stats">
          <div><strong>Age</strong>: ${age} years</div>
          <div><strong>Mean</strong>: ${simulation["mean"]}</div>
          <div><strong>Median</strong>: ${simulation["median"]}</div>
          <div><strong>Standard deviation</strong>: ${simulation["std_dev"]}</div>
          <div><strong>Standard error</strong>: ${simulation["std_err"]}</div>
          <div><strong>Min</strong>: ${simulation["min"]}</div>
          <div><strong>Max</strong>: ${simulation["max"]}</div>
          <div><strong>Simulations</strong>: ${simulation["simulations"]}</div>
        </div>
        <div id="kdePlot" class="plot-div"></div>
        ${renderEtfsTable(name)}
        ${renderCorrelationTable(4, name)}
        <div id="chartDiv" class="plot-div"></div>
      `;
      fetch(`${baseUrl}facts/indexes/${name}.csv`)
        .then(res => res.text())
        .then(csvData => {
          const rows = parseCSV(csvData);
          renderChart(name, rows.map(r => r[0]), rows.map(r => parseFloat(r[1])));
        });
      updateKDE(name);
    }

    // Event Listeners and Routing
    horizonSelect.addEventListener('change', e => {
      selectedCombo = e.target.value;
      horizonSelect.value = selectedCombo;
      updateUrl();
      updateHomeLink();
      if (currentRoute === 'home') renderTable();
      else if (currentRoute === 'view') showChart(currentIndexName);
    });

    adjustCurrencyCheckbox.addEventListener('change', e => {
      adjustCurrency = e.target.checked ? "adjust-currency" : "ignore-currency";
      adjustCurrencyCheckbox.checked = e.target.checked;
      updateUrl();
      updateHomeLink();
      if (currentRoute === 'home') renderTable();
      else if (currentRoute === 'view') showChart(currentIndexName);
    });

    adjustInflationCheckbox.addEventListener('change', e => {
      adjustInflation = e.target.checked ? "adjust-inflation" : "ignore-inflation";
      adjustInflationCheckbox.checked = e.target.checked;
      updateUrl();
      updateHomeLink();
      if (currentRoute === 'home') renderTable();
      else if (currentRoute === 'view') showChart(currentIndexName);
    });

    document.getElementById('xMinSelect').addEventListener('change', e => {
      xAxisMin = e.target.value === 'Auto' ? 'Auto' : Number(e.target.value);
      updateUrl();
      updateHomeLink();
      if (currentRoute === 'home') renderTable();
      else if (currentRoute === 'view') showChart(currentIndexName);
    });

    document.getElementById('xMaxSelect').addEventListener('change', e => {
      xAxisMax = e.target.value === 'Auto' ? 'Auto' : Number(e.target.value);
      updateUrl();
      updateHomeLink();
      if (currentRoute === 'home') renderTable();
      else if (currentRoute === 'view') showChart(currentIndexName);
    });

    router.on({
      '/': ({ params }) => dataLoaded.then(() => {
        applyParams(params);
        showTable();
        currentRoute = 'home';
        currentIndexName = null;
      }),
      '/view/:name': ({ data, params }) => dataLoaded.then(() => {
        applyParams(params);
        showChart(data.name);
        currentRoute = 'view';
      })
    });
    router.resolve();
  </script>
</body>
</html>
