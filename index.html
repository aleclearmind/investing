<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Indexes Viewer</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <script src="https://unpkg.com/navigo@8.11.1/lib/navigo.min.js"></script>
  <style id="dynamic-styles"></style>
  <style>
    .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px; /* Space between items */
        max-width: 100%; /* Ensure it fits the container */
        box-sizing: border-box;
    }

    .stats > div {
        white-space: nowrap; /* Prevent text wrapping */
    }

    .correlation-table {
      width: 10%;
      overflow-x: auto;
      margin: auto;
    }
    .correlation-table th {
      text-align: right;
      white-space: nowrap;
      left: 0px;
      position: sticky;
      font-weight: normal;
    }
    .correlation-table th:not(:first-child) {
      writing-mode: vertical-lr;
    }
    .correlation-table td {
      text-align: right;
    }
    .correlation-table-container {
      max-width: 100%;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <nav class="navbar navbar-expand-lg navbar-dark mb-4">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Indexes Viewer</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <span class="ms-auto">
          <input class="form-check-input" type="checkbox" value="" id="adjust-currency" checked>
          <label class="form-check-label" for="adjust-currency">
            Adjust currency
          </label>
        </span>
        <span style="margin-left: 1em">
          <input class="form-check-input" type="checkbox" value="" id="adjust-inflation" checked>
          <label class="form-check-label" for="adjust-inflation">
            Adjust inflation
          </label>
        </span>
        <span class="kde-controls" style="margin-left: 1em">
          <label for="xMinSelect" style="margin-right: 0.5em">Min:</label>
          <select id="xMinSelect" class="form-select d-inline-block" style="width: auto; margin-right: 1em">
          </select>
          <label for="xMaxSelect" style="margin-right: 0.5em">Max:</label>
          <select id="xMaxSelect" class="form-select d-inline-block" style="width: auto">
          </select>
        </span>
        <select style="margin-left: 1em" id="horizonSelect" class="form-select horizon-select"></select>
      </div>
    </div>
  </nav>
  <div id="app" class="container"></div>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Determine the base path dynamically
    const baseUrl = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) + '/';

    const COLORS = {
      background: '#212529',
      navbar: '#343a40',
      text: '#f8f9fa',
      link: '#a3e1d4',
      linkHover: '#f5b7b1',
      chartLine: '#a3e1d4',
      chartFill: 'rgba(163, 225, 212, 0.7)',
      kdeLine: '#f5b7b1',
      kdeFills: [
        'rgba(245, 183, 177, 0.7)', 'rgba(250, 215, 160, 0.7)', 'rgba(163, 225, 212, 0.7)',
        'rgba(164, 202, 240, 0.7)', 'rgba(204, 182, 255, 0.7)', 'rgba(221, 221, 221, 0.7)'
      ],
      meanLine: 'rgb(0, 255, 0)',
      medianLine: 'rgb(0, 0, 255)',
      zeroLine: 'rgb(255, 255, 255)',
      grid: '#495057',
      greenLight: 'hsl(120, 40%, 70%)',
      greenDark: 'hsl(120, 20%, 50%)'
    };

    document.getElementById('dynamic-styles').textContent = `
      body { font-family: Arial, sans-serif; padding: 20px; background-color: ${COLORS.background}; color: ${COLORS.text}; }
      .plot-div { width: 100%; height: 400px; }
      .navbar { background-color: ${COLORS.navbar} !important; border-radius: 10px; padding: 5px 10px; }
      a { color: ${COLORS.link}; }
      a:hover { color: ${COLORS.linkHover}; }
      .horizon-select { min-width: 120px; max-width: 30%; }
      .table { margin-bottom: 20px; }
      .table td.number, .table th.number { text-align: right; }
      .sort-link { text-decoration: none; margin-left: 5px; }
      .sort-link:hover { color: ${COLORS.linkHover}; }
    `;

    const COMBINATIONS = (() => {
      const yearsOptions = [10, 15, 20, 25, 'max'];
      const holdOptions = [1.0, 3.0, 5.0, 10.0];
      return holdOptions.flatMap(hold =>
        yearsOptions.map(years => ({
          hold: hold.toFixed(1),
          years,
          value: `hold-${hold.toFixed(1)}/years-${years}`,
          label: `Hold for ${hold} years / Data for ${years === 'max' ? 'all' : years} years`
        }))
      ).filter(value => value.years == "max" || (value.years >= new Number(value.hold)));
    })();

    const app = document.getElementById('app');
    const router = new Navigo(baseUrl, { hash: true });
    let selectedCombo = "hold-10.0/years-20";
    let adjustCurrency = "adjust-currency";
    let adjustInflation = "adjust-inflation";
    let xAxisMin = 'Auto';
    let xAxisMax = 'Auto';
    let indexesMeta = {}, simulationsData = {}, etfsData = [], currentIndexName = null;
    let sortState = { column: "", ascending: true };
    let etfSortState = { column: "", ascending: true };
    let currentRoute = 'home';
    let correlationsData = {};
    let minCorrelation = 1;

    const baseLayout = {
      plot_bgcolor: COLORS.navbar,
      paper_bgcolor: COLORS.background,
      font: { color: COLORS.text },
      xaxis: { gridcolor: COLORS.grid },
      yaxis: { gridcolor: COLORS.grid },
      margin: { t: 20, b: 50, l: 50, r: 20 },
      showlegend: false
    };

    // Generate options for x-axis range dropdowns (-20 to +20)
    const rangeMin = -20;
    const rangeMax = 20;
    const rangeOptions = ['Auto', ...Array.from({length: rangeMax - rangeMin + 1}, (_, i) => i + rangeMin)];

    const horizonSelect = document.getElementById('horizonSelect');
    horizonSelect.innerHTML = COMBINATIONS.map(c => `<option value="${c.value}">${c.label}</option>`).join('');
    horizonSelect.value = selectedCombo;

    const adjustCurrencyCheckbox = document.getElementById('adjust-currency');
    adjustCurrencyCheckbox.checked = adjustCurrency === "adjust-currency";
    const adjustInflationCheckbox = document.getElementById('adjust-inflation');
    adjustInflationCheckbox.checked = adjustInflation === "adjust-inflation";

    const homeLink = document.querySelector('.navbar-brand');

    let config = {};

    // Centralized CSV Parsing
    function parseCSV(csvData) {
      const lines = csvData.trim().split('\n').slice(1); // Skip header
      return lines.map(line => {
        const result = [];
        let current = '', inQuotes = false;
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"' && !inQuotes) {
            inQuotes = true;
          } else if (char === '"' && inQuotes) {
            inQuotes = false;
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current.trim()); // Push last field
        return result.map(field => field.replace(/^"|"$/g, '')); // Strip quotes
      });
    }

    function fetchCSV(url) {
      return fetch(`${baseUrl}${url}`).then(res => res.text()).then(parseCSV);
    }

    function fetchJSON(url) {
      return fetch(`${baseUrl}${url}`).then(res => res.json());
    }

    function loadConfig() {
      return fetchJSON("config.json").then(response => {
        config = response;
      });
    }

    function loadCorrelationsData() {
      return fetchCSV('facts/indexes-correlation.csv').then(rows => {
        correlationsData = {};
        rows.forEach(([a, b, , correlation]) => {
          if (!correlationsData[a]) correlationsData[a] = {};
          if (!correlationsData[b]) correlationsData[b] = {};
          value = parseFloat(correlation)
          if (minCorrelation > value)
            minCorrelation = value;
          value = parseFloat(correlation);
          correlationsData[a][b] = value;
          correlationsData[b][a] = value;
        });
      });
    }

    // Data Loading
    function loadIndexesMeta() {
      return fetchCSV('facts/indexes.csv').then(rows => {
        const currentDate = new Date(config["max_date"]);
        indexesMeta = {};
        rows.forEach(([name, full_name, code, currency, earliest_date, url]) => {
          full_name = full_name.replace(/ Index$/, '');
          // Only include indices that have at least one ETF
          if (name === "null" || etfsData.some(etf => etf.indexName === name)) {
            const years = ((currentDate - new Date(earliest_date)) / (1000 * 60 * 60 * 24 * 365.25)).toFixed(1);
            indexesMeta[name] = { full_name, code, currency, earliest_date, years: parseFloat(years), url };
          }
        });
      });
    }

    function loadSimulationsData() {
      return fetchCSV('simulations/indexes.csv').then(rows => {
        rows.forEach(([index, hold_years, total_years, adjustCurrency, adjustInflation, simulations, mean, median, std_dev, std_err, min, max]) => {
          // Only process simulations for indices in indexesMeta
          if (indexesMeta[index]) {
            if (!simulationsData[index]) simulationsData[index] = {};
            const key = `hold-${hold_years}/years-${total_years}/${adjustCurrency}/${adjustInflation}`;
            simulationsData[index][key] = {
              simulations: Math.round(Number(simulations)),
              mean: Number(mean),
              median: Number(median),
              std_dev: 100 * Number(std_dev),
              std_err: 100 * Number(std_err),
              min: Number(min),
              max: Number(max)
            };
          }
        });
      });
    }

    function loadEtfsData() {
      return fetchCSV('facts/etfs.csv').then(rows => {
        const currentDate = new Date(config["max_date"]);
        etfsData = rows.map(([indexName, isin, shareName, currency, currencyHedged, indexComparisonDatapointCount, indexCorrelation, indexAverageDifferenceInYearlyReturns, adjustedIndexComparisonDatapointCount, adjustedIndexCorrelation, adjustedIndexAverageDifferenceInYearlyReturns, expenseRatio, provider, replicationMethod, replicationModel, dividendPolicyId, creationDate, size, trackingError, trackingDifference, description, trackinsightTicker]) => {
          const years = ((currentDate - new Date(creationDate)) / (1000 * 60 * 60 * 24 * 365.25)).toFixed(1);
          return {
            indexName, isin, shareName, currencyHedged: currencyHedged === 'True', expenseRatio: Number(expenseRatio),
            provider: provider.replace(" by DWS", ""), replicationMethod, replicationModel, dividendPolicyId, creationDate, years: parseFloat(years),
            currency, size: Number(size) / 1e9, trackingError: Number(trackingError), trackingDifference: Number(trackingDifference),
            description, trackinsightTicker,
            indexComparisonDatapointCount: Number(indexComparisonDatapointCount), indexCorrelation: Number(indexCorrelation), indexAverageDifferenceInYearlyReturns: Number(indexAverageDifferenceInYearlyReturns), adjustedIndexComparisonDatapointCount: Number(adjustedIndexComparisonDatapointCount), adjustedIndexCorrelation: Number(adjustedIndexCorrelation), adjustedIndexAverageDifferenceInYearlyReturns: Number(adjustedIndexAverageDifferenceInYearlyReturns)
          };
        }).filter(entry => ((entry.currencyHedged && entry.currency == "EUR") || entry.currency == "USD") && entry.dividendPolicyId == "Capitalization");
      });
    }

    const dataLoaded = loadConfig().then(loadEtfsData).then(loadIndexesMeta).then(loadSimulationsData).then(loadCorrelationsData);

    // Utility Functions
    function buildQuery() {
      const params = {
        combo: selectedCombo,
        ac: adjustCurrency === "adjust-currency" ? '1' : '0',
        ai: adjustInflation === "adjust-inflation" ? '1' : '0',
        s: `${sortState.column},${sortState.ascending ? 'true' : 'false'}`,
        es: `${etfSortState.column},${etfSortState.ascending ? 'true' : 'false'}`,
        xmin: xAxisMin !== 'Auto' ? xAxisMin : '',
        xmax: xAxisMax !== 'Auto' ? xAxisMax : ''
      };
      return new URLSearchParams(params).toString();
    }

    function updateUrl() {
      const lastRoute = router.lastResolved();
      const path = lastRoute && lastRoute.length > 0 ? lastRoute[0].url : (currentRoute === 'view' && currentIndexName ? `${baseUrl}view/${currentIndexName}` : '/');
      const query = buildQuery();
      router.navigate(path + (query ? '?' + query : ''));
    }

    function updateHomeLink() {
      homeLink.href = `#${baseUrl}?${buildQuery()}`;
    }

    function applyParams(params) {
      const p = params || {};
      const ac = p.ac ?? '1';
      adjustCurrency = ac === '1' ? "adjust-currency" : "ignore-currency";
      const ai = p.ai ?? '1';
      adjustInflation = ai === '1' ? "adjust-inflation" : "ignore-inflation";
      selectedCombo = p.combo ?? "hold-10.0/years-20";
      const s = p.s ?? '0,true';
      const [col, ascStr] = s.split(',');
      sortState.column = col;
      sortState.ascending = ascStr === 'true';
      const es = p.es ?? '0,true';
      const [etfCol, etfAscStr] = es.split(',');
      etfSortState.column = etfCol;
      etfSortState.ascending = etfAscStr === 'true';
      xAxisMin = p.xmin && rangeOptions.includes(Number(p.xmin)) ? Number(p.xmin) : 'Auto';
      xAxisMax = p.xmax && rangeOptions.includes(Number(p.xmax)) ? Number(p.xmax) : 'Auto';

      horizonSelect.value = selectedCombo;
      adjustCurrencyCheckbox.checked = ac === '1';
      adjustInflationCheckbox.checked = ai === '1';
      const xMinSelect = document.getElementById('xMinSelect');
      const xMaxSelect = document.getElementById('xMaxSelect');
      if (xMinSelect) xMinSelect.value = xAxisMin;
      if (xMaxSelect) xMaxSelect.value = xAxisMax;

      xMinSelect.innerHTML = `
        ${rangeOptions.map(val => `<option value="${val}">${val >= 0 ? '+' : ''}${val}%</option>`).join('')}
      `;
      xMaxSelect.innerHTML = `
        ${rangeOptions.map(val => `<option value="${val}">${val >= 0 ? '+' : ''}${val}%</option>`).join('')}
      `;

      xMinSelect.value = xAxisMin;
      xMaxSelect.value = xAxisMax;

      updateHomeLink();
    }

    function getColorScale(value, min, max, lowerIsBetter = false) {
      if (value === undefined) return COLORS.text;
      value = Math.min(max, Math.max(min, value));
      const ratio = (value - min) / (max - min) || 0;
      return `hsl(${lowerIsBetter ? 120 * (1 - ratio) : 120 * ratio}, 40%, 70%)`;
    }

    function sortTable(columnName) {
      sortState = { column: columnName, ascending: sortState.column === columnName ? !sortState.ascending : true };
      updateUrl();
      updateHomeLink();
      const table = renderTable(currentIndexName);
      document.querySelector('#indexesTable tbody').innerHTML = table.body;
    }

    function sortEtfsTable(columnName) {
      etfSortState = { column: columnName, ascending: etfSortState.column === columnName ? !etfSortState.ascending : true };
      updateUrl();
      updateHomeLink();
      const table = renderEtfsTable(currentIndexName);
      document.querySelector('#etfsTable').outerHTML = table;
    }

    function renderCorrelationTable(digits, selectedIndex = null) {
      const queryStr = buildQuery();

      let indexes = Object.keys(indexesMeta).sort((a, b) =>
        indexesMeta[a].full_name.localeCompare(indexesMeta[b].full_name)
      );

      // Sort indexes by correlation in ascending order if selectedIndex is provided
      if (selectedIndex) {
        indexes = indexes.sort((a, b) => {
          const corrA = correlationsData[a]?.[selectedIndex] || 0;
          const corrB = correlationsData[b]?.[selectedIndex] || 0;
          return corrA - corrB; // Ascending order
        });
      }

      // Determine headers based on whether a specific index is selected
      const headerRow = selectedIndex
        ? ""
        : `<tr><th></th>${indexes.map(index => `<th><a href="#${baseUrl}view/${index}?${queryStr}">${indexesMeta[index].full_name || index}</a></th>`).join('')}</tr>`;

      // Determine which indexes to include in columns
      const columns = selectedIndex ? [selectedIndex] : indexes;

      // Generate table body
      const bodyRows = indexes.map(indexA => {
        if (selectedIndex && indexA === selectedIndex)
          return "";
        const cells = columns.map(indexB => {
          const value = correlationsData[indexA]?.[indexB];
          if (value === undefined)
            return `<td></td>`;
          const correlation = value.toFixed(digits).replace("1.00", "1").replace("0.", ".") || '';
          return `<td style="color: ${getColorScale(Math.max(0.9, value), 0.9, 1, true)}">${correlation}</td>`;
        });
        return `
          <tr>
            <th><a href="#${baseUrl}view/${indexA}?${queryStr}">${indexesMeta[indexA].full_name || indexA}</a></th>
            ${cells.join('')}
          </tr>
        `;
      }).join('');

      return `
        <h3>Comparison with other indexes</h3>
        <div class="correlation-table-container">
          <table class="table table-dark table-striped table-hover correlation-table">
            <thead>${headerRow}</thead>
            <tbody>${bodyRows}</tbody>
          </table>
        </div>
      `;
    }

    function formatNumber(value, type, digits, force_plus=false) {
      digits = digits || 2;

      const positive_prefix = force_plus ? "+" : "";

      if (value === undefined) {
        return "N/A";
      } else if (type === "string") {
        return value;
      } else if (type === "percentage") {
        value = value * 100;
        return value > 0 ? `${positive_prefix}${value.toFixed(digits)}%` : `${value.toFixed(digits)}%`;
      } else if (type === "integer") {
        return value > 0 ? `${positive_prefix}${value}` : `${value}`;
      } else if (type === "float") {
        return value > 0 ? `${positive_prefix}${value.toFixed(digits)}` : `${value.toFixed(digits)}`;
      }
    }

    // Rendering Functions
    function renderTable(referenceIndex = null) {

      // Define columns inline
      let columns = [
        { name: 'Index', key: 'full_name', type: "string" },
        { name: 'Currency', key: 'currency', type: "string" },
        { name: 'Years', key: 'years', type: "float", digits: 1, lowerIsBetter: false },
        { name: 'Mean', key: 'mean', type: "percentage", lowerIsBetter: false },
        { name: 'Median', key: 'median', type: "percentage", lowerIsBetter: false },
        { name: 'σ', key: 'std_dev', type: "float", lowerIsBetter: true },
        { name: 'SE', key: 'std_err', type: "float", lowerIsBetter: true },
        { name: 'Min', key: 'min', type: "percentage", lowerIsBetter: false },
        { name: 'Max', key: 'max', type: "percentage", lowerIsBetter: false },
        { name: 'ETF #', key: 'etfCount', type: "integer", lowerIsBetter: false },
        { name: 'URL', key: 'url', type: "string" }
      ];

      let isNumeric = (type) => type != "string";

      // Build flat indexesData
      let indexesData = Object.keys(indexesMeta).map(name => ({
        name,
        full_name: indexesMeta[name].full_name || 'N/A',
        currency: indexesMeta[name].currency || 'N/A',
        years: indexesMeta[name].years,
        url: indexesMeta[name].url,
        ...simulationsData[name]?.[`${selectedCombo}/${adjustCurrency}/${adjustInflation}`] || {},
        etfCount: etfsData.filter(etf => etf.indexName === name).length
      }));

      // If referenceIndex is provided, transform data to differences
      if (referenceIndex) {

        columns.splice(1, 0, { name: 'Correlation', key: 'correlation', type: "float", digits: 4, lowerIsBetter: true });

        let referenceData = indexesData.find(d => d.name === referenceIndex);
        if (referenceData) {
          indexesData.forEach(data => {
            if (data.name !== referenceIndex) {
              data.correlation = correlationsData[data.name]?.[referenceIndex];
              columns.forEach(column => {
                if (column.key !== "correlation" && isNumeric(column.type)) {
                  const value = data[column.key];
                  const refValue = referenceData[column.key];
                  data[column.key] = (value !== undefined && refValue !== undefined) ? (value - refValue) : undefined;
                }
              });
            }
          });

          columns.forEach(column => {
            if (column.key !== "correlation" && isNumeric(column.type)) {
              referenceData[column.key] = 0;
            }
          });
          referenceData["correlation"] = 1;

        }
      }

      let columnIndex = columns.reduce((map, entry) => { map[entry.key] = entry; return map }, {});

      indexesData = indexesData.filter((entry) => entry.mean !== undefined);

      // Sort data
      indexesData.sort((a, b) => {
        let column = columnIndex[sortState.column];
        if (column === undefined) {
          console.log(`${sortState.column} not found in:`, columns);
          return 0;
        }
        let defaultValue = column.lowerIsBetter ? Infinity : -Infinity;
        let sort = isNumeric(column.type) ? ((a, b) => (a[column.key] || defaultValue) - (b[column.key] || defaultValue)) : ((a, b) => a[column.key].localeCompare(b[column.key]));
        return sortState.ascending ? sort(b, a) : sort(a, b);
      });

      // Calculate ranges for color scaling
      const ranges = columns.reduce((acc, column) => {
        if (isNumeric(column.type)) {
          const values = indexesData.map(d => d[column.key]).filter(v => v !== undefined);
          acc[column.key] = { min: Math.min(...values), max: Math.max(...values) };
        }
        return acc;
      }, {});

      ranges.correlation = { min: 0.9, max: 1 };

      const queryStr = buildQuery();

      // Generate table header
      const header = `<thead><tr>${columns.map((column, i) => `
        <th${isNumeric(column.type) ? ' class="number"' : ''}><a href="#" class="sort-link" data-col="${column.key}">${column.name}</a></th>
      `).join('')}</tr></thead>`;

      // Generate table body
      const body = indexesData.map(data => {
        const rowData = columns.map(column => {
          const value = data[column.key];
          if (column.key === 'full_name') {
            return `<td class="number"><a href="#${baseUrl}view/${data.name}?${queryStr}">${value}</a></td>`;
          } else if (column.key === 'url') {
            return `<td><a href="${value}">W</a></td>`;
          } else if (column.type === 'string') {
            return `<td>${value}</td>`;
          } else {
            let color = getColorScale(value, ranges[column.key].min, ranges[column.key].max, column.lowerIsBetter);
            return `<td class="number" style="color: ${color}">${formatNumber(value, column.type, column.digits, referenceIndex)}</td>`;
          }
        });
        return `<tr>${rowData.join('')}</tr>`;
      }).join('');

      return { header, body };
    }

    function showTable() {
      const table = renderTable();
      app.innerHTML = `
        <table id="indexesTable" class="table table-dark table-striped table-hover">
          ${table.header}
          <tbody>${table.body}</tbody>
        </table>
        ${renderCorrelationTable(2)}
      `;
      document.querySelectorAll('#indexesTable .sort-link').forEach(link => link.addEventListener('click', e => { e.preventDefault(); sortTable(link.dataset.col); }));
    }

    function renderChart(name, x, y) {
      const fullName = indexesMeta[name]?.full_name || 'N/A';
      Plotly.newPlot('chartDiv', [{
        x, y, type: 'scatter', mode: 'lines', fill: 'tozeroy', line: { color: COLORS.chartLine }, fillcolor: COLORS.chartFill, name: fullName
      }], { ...baseLayout, xaxis: { ...baseLayout.xaxis, title: 'Date' }, yaxis: { ...baseLayout.yaxis, title: 'Value' } });
    }

    function renderKDE(divId, data) {
      const x = data.kde_points.map(point => 100 * point.x);
      const y = data.kde_points.map(point => point.density);
      const percentiles = data.percentiles;
      const traces = COLORS.kdeFills.map((color, i) => {
        const ranges = [null, '5th', '25th', '50th', '75th', '95th', null];
        const [min, max] = [ranges[i], ranges[i + 1]].map(r => r ? 100 * percentiles[r] : null);
        const startIdx = min === null ? 0 : x.findIndex(val => val > min);
        const endIdx = max === null ? x.length : x.findIndex(val => val >= max) + 1;
        return { x: x.slice(startIdx, endIdx), y: y.slice(startIdx, endIdx), type: 'scatter', mode: 'lines', fill: 'tozeroy', fillcolor: color, line: { width: 0 } };
      });
      traces.push({ x, y, type: 'scatter', mode: 'lines', line: { shape: 'spline', color: COLORS.kdeLine } });
      const verticalLinesData = [
        { value: 100 * data.mean, color: COLORS.meanLine, dash: 'dash' },
        { value: 100 * data.median, color: COLORS.medianLine, dash: 'dash' },
        { value: 0, color: COLORS.zeroLine, dash: 'solid' }
      ];
      traces.push(...verticalLinesData.map(line => ({
        x: [line.value, line.value], y: [0, Math.max(...y)], type: 'scatter', mode: 'lines', line: { color: line.color, dash: line.dash }
      })));
      const tickVals = x.filter((_, i) => i % Math.floor(x.length / 5) === 0);
      const tickText = tickVals.map(val => val.toFixed(2) > 0 ? `+${val.toFixed(2)}%` : `${val.toFixed(2)}%`);

      // Apply x-axis range if specified
      const xaxis = {
        ...baseLayout.xaxis,
        title: 'Return',
        tickvals: tickVals,
        ticktext: tickText,
        tickformat: '.2f'
      };

      if (xAxisMin !== 'Auto') xaxis.range = [xAxisMin, xaxis.range ? xaxis.range[1] : Math.max(...x)];
      if (xAxisMax !== 'Auto') xaxis.range = [xaxis.range ? xaxis.range[0] : Math.min(...x), xAxisMax];

      Plotly.newPlot(divId, traces, {
        ...baseLayout,
        xaxis,
        yaxis: { ...baseLayout.yaxis, title: 'Density' },
        shapes: verticalLinesData.map(line => ({
          type: 'line',
          x0: line.value,
          x1: line.value,
          y0: 0,
          y1: Math.max(...y),
          line: { color: line.color, dash: line.dash }
        }))
      });
    }

    function updateKDE(name) {
      if (!indexesMeta[name]) return;
      const [hold, years] = selectedCombo.split('/').map(part => part.split('-')[1]);
      document.getElementById('kdePlot').innerHTML = "";
      fetch(`${baseUrl}simulations/${name}/hold-${hold}/years-${years}/${adjustCurrency}/${adjustInflation}/kde.json`)
        .then(res => res.json())
        .then(data => renderKDE('kdePlot', data))
        .catch(() => document.getElementById('kdePlot').innerHTML = `<p class="text-danger">No data for ${hold}-year hold / ${years}-year simulation.</p>`);
    }

    function renderEtfsTable(name) {
      if (!indexesMeta[name]) return '<p>Index not found.</p>';
      let relatedEtfs = etfsData.filter(etf => etf.indexName === name);
      if (!relatedEtfs.length) return '<p>No ETFs available for this index.</p>';

      const columns = [
        { name: 'ISIN', key: 'isin', type: 'string' },
        { name: 'Provider', key: 'provider', type: 'string' },
        { name: 'Size', key: 'size', type: 'float', lowerIsBetter: false, digits: 2 },
        { name: 'Years', key: 'years', type: 'float', lowerIsBetter: false, digits: 1 },
        { name: 'TER', key: 'expenseRatio', type: 'percentage', lowerIsBetter: true, digits: 2 },
        { name: 'Currency', key: 'currencyDisplay', type: 'string' },
        { name: 'Correlation', key: 'indexCorrelation', type: 'float', lowerIsBetter: false, digits: 4 },
        { name: 'Return diff.', key: 'indexAverageDifferenceInYearlyReturns', type: 'percentage', lowerIsBetter: false, digits: 2 },
        { name: 'Correlation (adj)', key: 'adjustedIndexCorrelation', type: 'float', lowerIsBetter: false, digits: 4 },
        { name: 'Return diff. (adj)', key: 'adjustedIndexAverageDifferenceInYearlyReturns', type: 'percentage', lowerIsBetter: false, digits: 2 },
        { name: 'R. Model', key: 'replicationModel', type: 'string' },
        { name: 'BI', key: 'biLink', type: 'string' },
        { name: 'TI', key: 'tiLink', type: 'string' },
        { name: 'JE', key: 'jeLink', type: 'string' }
      ];

      // Prepare ETF data with display values
      relatedEtfs = relatedEtfs.map(etf => ({
        ...etf,
        currencyDisplay: `${etf.currencyHedged ? 'h' : ''}${etf.currency}`,
        biLink: `<a href="https://www.borsaitaliana.it/borsa/etf/scheda/${etf.isin}.html" target="_blank">BI</a>`,
        tiLink: `<a href="https://www.trackinsight.com/en/fund/${etf.trackinsightTicker}" target="_blank">TI</a>`,
        jeLink: `<a href="https://www.justetf.com/en/etf-profile.html?isin=${etf.isin}" target="_blank">JE</a>`
      }));

      // Calculate ranges for color scaling
      const isGood = (value) => value !== undefined && !Number.isNaN(value);
      const ranges = columns.reduce((acc, column) => {
        if (column.type === 'percentage' || column.type === 'float') {
          const values = relatedEtfs.map(e => e[column.key]).filter(isGood);
          acc[column.key] = { min: Math.min(...values), max: Math.max(...values) };
        }
        return acc;
      }, {});

      // Sort ETFs
      relatedEtfs.sort((a, b) => {
        const column = columns.find(c => c.key === etfSortState.column);
        if (!column) return 0;
        const defaultValue = column.lowerIsBetter ? Infinity : -Infinity;
        const aVal = isGood(a[etfSortState.column]) ? a[etfSortState.column] : defaultValue;
        const bVal = isGood(b[etfSortState.column]) ? b[etfSortState.column] : defaultValue;
        let result;
        if (column.type === 'string') {
          result = aVal.localeCompare(bVal);
        } else {
          result = aVal - bVal;
        }
        return etfSortState.ascending ? result : -result;
      });

      const tableHeader = `<thead><tr>${columns.map(column => `
        <th${(column.type === 'percentage' || column.type === 'float') ? ' class="number"' : ''}><a href="#" class="sort-link" data-col="${column.key}">${column.name}</a></th>
      `).join('')}</tr></thead>`;

      const tableBody = relatedEtfs.map(etf => {
        const rowData = columns.map(column => {
          const value = etf[column.key];
          if (['biLink', 'tiLink', 'jeLink'].includes(column.key)) {
            return `<td>${value}</td>`;
          } else if (column.type === 'string') {
            return `<td${column.key === 'isin' ? ' title="' + etf.shareName + '" style="font-family: monospace"' : ''}>${value}</td>`;
          } else {
            const color = getColorScale(value, ranges[column.key].min, ranges[column.key].max, column.lowerIsBetter);
            return `<td class="number" style="color: ${color}">${formatNumber(value, column.type, column.digits)}</td>`;
          }
        });
        return `<tr>${rowData.join('')}</tr>`;
      }).join('');

      return `
        <h3>Related ETFs</h3>
        <table class="table table-dark table-striped table-hover" id="etfsTable">
          ${tableHeader}
          <tbody>${tableBody}</tbody>
        </table>
      `;
    }

    function showChart(name) {
      currentIndexName = name;
      let { full_name = 'N/A', years = "N/A", currency, url } = indexesMeta[name] || {};
      const age = years;
      const [hold, yearsData] = selectedCombo.split('/').map(part => part.split('-')[1]);
      const key = `hold-${hold}/years-${yearsData}/${adjustCurrency}/${adjustInflation}`;
      const simulation = simulationsData[name]?.[key] || {};
      const table = renderTable(name);
      app.innerHTML = `
        <h2>${full_name}</h2>
        <div class="stats">
          <div><a href="${url}">Website</a></div>
          <div><strong>Age</strong>: ${age} years</div>
          <div><strong>Currency</strong>: ${currency}</div>
          <div><strong>Mean</strong>: ${formatNumber(simulation["mean"], "percentage")}</div>
          <div><strong>Median</strong>: ${formatNumber(simulation["median"], "percentage")}</div>
          <div><strong>Standard deviation</strong>: ${formatNumber(simulation["std_dev"], "float")}</div>
          <div><strong>Standard error</strong>: ${formatNumber(simulation["std_err"], "float")}</div>
          <div><strong>Min</strong>: ${formatNumber(simulation["min"], "percentage")}</div>
          <div><strong>Max</strong>: ${formatNumber(simulation["max"], "percentage")}</div>
          <div><strong>Simulations</strong>: ${simulation["simulations"]}</div>
        </div>
        <div id="kdePlot" class="plot-div"></div>
        ${renderEtfsTable(name)}
        <h3>Comparison with other indexes</h3>
        <table id="indexesTable" class="table table-dark table-striped table-hover">
          ${table.header}
          <tbody>${table.body}</tbody>
        </table>
        <h3>Historical data</h3>
        <div id="chartDiv" class="plot-div"></div>
      `;
      fetch(`${baseUrl}facts/indexes/${name}.csv`)
        .then(res => res.text())
        .then(csvData => {
          const rows = parseCSV(csvData);
          renderChart(name, rows.map(r => r[0]), rows.map(r => parseFloat(r[1])));
        });
      updateKDE(name);
      document.querySelectorAll('#indexesTable .sort-link').forEach(link => link.addEventListener('click', e => { e.preventDefault(); sortTable(link.dataset.col); }));
      document.querySelectorAll('#etfsTable .sort-link').forEach(link => link.addEventListener('click', e => { e.preventDefault(); sortEtfsTable(link.dataset.col); }));
    }

    // Event Listeners and Routing
    horizonSelect.addEventListener('change', e => {
      selectedCombo = e.target.value;
      horizonSelect.value = selectedCombo;
      updateUrl();
      updateHomeLink();
      if (currentRoute === 'home') {
        const table = renderTable();
        document.querySelector('#indexesTable tbody').innerHTML = table.body;
      } else if (currentRoute === 'view') {
        showChart(currentIndexName);
      }
    });

    adjustCurrencyCheckbox.addEventListener('change', e => {
      adjustCurrency = e.target.checked ? "adjust-currency" : "ignore-currency";
      adjustCurrencyCheckbox.checked = e.target.checked;
      updateUrl();
      updateHomeLink();
      if (currentRoute === 'home') {
        const table = renderTable();
        document.querySelector('#indexesTable tbody').innerHTML = table.body;
      } else if (currentRoute === 'view') {
        showChart(currentIndexName);
      }
    });

    adjustInflationCheckbox.addEventListener('change', e => {
      adjustInflation = e.target.checked ? "adjust-inflation" : "ignore-inflation";
      adjustInflationCheckbox.checked = e.target.checked;
      updateUrl();
      updateHomeLink();
      if (currentRoute === 'home') {
        const table = renderTable();
        document.querySelector('#indexesTable tbody').innerHTML = table.body;
      } else if (currentRoute === 'view') {
        showChart(currentIndexName);
      }
    });

    document.getElementById('xMinSelect').addEventListener('change', e => {
      xAxisMin = e.target.value === 'Auto' ? 'Auto' : Number(e.target.value);
      updateUrl();
      updateHomeLink();
      if (currentRoute === 'home') {
        const table = renderTable();
        document.querySelector('#indexesTable tbody').innerHTML = table.body;
      } else if (currentRoute === 'view') {
        showChart(currentIndexName);
      }
    });

    document.getElementById('xMaxSelect').addEventListener('change', e => {
      xAxisMax = e.target.value === 'Auto' ? 'Auto' : Number(e.target.value);
      updateUrl();
      updateHomeLink();
      if (currentRoute === 'home') {
        const table = renderTable();
        document.querySelector('#indexesTable tbody').innerHTML = table.body;
      } else if (currentRoute === 'view') {
        showChart(currentIndexName);
      }
    });

    router.on({
      '/': ({ params }) => dataLoaded.then(() => {
        applyParams(params);
        showTable();
        currentRoute = 'home';
        currentIndexName = null;
      }),
      '/view/:name': ({ data, params }) => dataLoaded.then(() => {
        applyParams(params);
        showChart(data.name);
        currentRoute = 'view';
      })
    });
    router.resolve();
  </script>
</body>
</html>
